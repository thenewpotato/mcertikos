Compile: make / make all
Run tests: make clean && make TEST=1
Run in qemu: make qemu / make qemu-nox
Debug with gdb: make qemu-gdb / make qemu-nox-gdb
(in another terminal) gdb

To use your solutions from lab 1: git merge lab1
To use sample lab 1 solutions: copy files in samples/ to appropriate directories

List here the following info:

1. who you have worked with
2. whether you coded this assignment together, and if not, who worked on which part
3. brief description of what you have implemented
4. and anything else you would like us to know

# Collaborators

- Tiger Wang (jw2723)
- Jackie Dong (jd2598)

# Part 1: Scheduler Support: Sleep and Wakeup

In this part, we implemented more scheduler support in McCertikos. Specifically, we implemented thread_sleep and thread_wakeup which allow threads to sleep until certain resources are available for them to use. This is important specifically for disk writes where, we need to enable our threads to sleep until the disk write carries out. When the write is finished, the hard disk issues a special device interrupt signalaing the threads that were waiting for the write to finish to wake up.

# Part 2: Disk Driver

In this part, we just had to read the documentation about the xv6 file system.

# Part 3: File System Support

In this part we first implemented the functions dir_lookup and dir_link. In dir_lookup, we looped through the directory entries of a specified directory until we found an entry with a name that matched the name we were looking for. In dir_link, we used dir_lookup to find the specified sub directory and then wrote a new directory entry into it. After writing dir_lookup and dir_link, we implemented skippelem and namex in path.c. In skippelem, we parsed the necessary information from the specified path string to extract the next path element as well as the remaining path string. In namex, we found the coressponding inode for the path specified by parsing each element of the path string passed in using skipelem. Next, we altered the sys_link, sys_unlink, sys_open, sys_mkdir, and sys_chdir system calls by adding additional argument(s) in their int system calls corresspomnding to the string length of the user input. Next, we wrote the functions fdalloc, sys_read, sys_write, sys_close, and fstat. In fdalloc, we simply loop through the current threads open files to find an open file descriptor. We allocate the file descriptor to the specified file and then return the found file descriptor. In sys_read, we read x bytes into our global kernel buffer using file_read and then copy it into the user buffer with pt_copyout. In sys_write, we first copy in the user data into the kernel buffer using pt_copyin and then write to the specified file using file_write. In sys_fstat, we simply populate the file stat struct passed in using pt_copyout. Lastly, in exercise 15 we added spinlocks for sys_read and sys_write in critical sections where they operate on the global kernel buffer.

# Part 4: Shell

In this part of the lab we implemented a unix-like shell on top of our file system implementation. We first started by creating a new user program in user/shell called shell.c We first added the appropriate functionality to spawn this process by altering sys_spawn and kern/init/init.c Afterwards, we created implemented sys_readline, a system call to read in user input. This system call is essentially a wrapper for readline function in kern/dev/console.c. Next, we implemented a user input parser called findNextArg which takes in a pointer to a location within the user input returns the next user argument. Finally, we implemented the functionality for the following set of commands: ls, pwd, cd, cp, mv, rm, mkdir, cat, touch, writing a string to a file, and appending a string to a file.

# ls

For the ls command, we simply loop through the specified path directory's directory entries and print out the names of the entries. We implemented both support for ls without arguments and ls with arguments.

# pwd

# cd

For the cd command, we simply called the system call chdir with the specied path directory. We also decided to implement functionality for cd with no arguments, assuming that the HOME directory was "..".

# cp

# mv

For the mv command, we simply create a link between the source file and the destination file and then remove the link from the source file. We do this using the sys_link and sys_unlink system calls.

# mkdir

# cat

# touch

# echo "some content" > file (file writing)

# echo "some content" >> file (file appending)
